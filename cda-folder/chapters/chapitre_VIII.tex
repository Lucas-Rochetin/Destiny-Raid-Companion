\chapter{Déploiement et intégration continue (CI/CD)}

\section{Cadre et objectifs du déploiement}

Le déploiement de l’application \textit{Destiny Raid Companion} vise à garantir une mise en production fiable, reproductible et cohérente avec les contraintes d’un projet individuel de niveau Concepteur Développeur d’Applications.

L’approche retenue repose sur :
\begin{itemize}
    \item la containerisation de l’application avec Docker,
    \item l’automatisation des tests et du build via GitHub Actions,
    \item une séparation claire entre intégration continue (CI) et déploiement (CD),
    \item une supervision minimale post-déploiement.
\end{itemize}

Les choix techniques sont volontairement simples et réalistes afin de rester cohérents avec un contexte de projet solo.

\section{Containerisation de l’application avec Docker}

\subsection{Architecture des services}

L’application est structurée autour de deux composants principaux :
\begin{itemize}
    \item un \textbf{backend Node.js} exposant une API REST,
    \item un \textbf{frontend HTML/CSS/JavaScript} consommant l’API.
\end{itemize}

Cette architecture permet une séparation claire des responsabilités tout en restant simple à déployer.

\subsection{Dockerfile Backend (Node.js)}

\begin{lstlisting}[language=dockerfile]
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

EXPOSE 3000
ENV NODE_ENV=production

CMD ["node", "index.js"]
\end{lstlisting}

Ce Dockerfile permet :
\begin{itemize}
    \item un environnement Node.js stable,
    \item une installation reproductible des dépendances,
    \item un démarrage simple de l’API.
\end{itemize}

\subsection{Dockerfile Frontend (HTML / CSS / JavaScript)}

\begin{lstlisting}[language=dockerfile]
FROM nginx:alpine

COPY ./public /usr/share/nginx/html
EXPOSE 80
\end{lstlisting}

Le frontend est servi par Nginx, ce qui permet :
\begin{itemize}
    \item un chargement rapide des pages,
    \item une configuration simple,
    \item une séparation claire avec la logique backend.
\end{itemize}

\subsection{Orchestration avec Docker Compose}

\begin{lstlisting}[language=yaml]
version: "3.8"

services:
  frontend:
    build: ./frontend
    ports:
      - "8080:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - BUNGIE_API_KEY=${BUNGIE_API_KEY}
\end{lstlisting}

Docker Compose permet de lancer l’application complète avec une seule commande.

\section{Gestion des environnements et des variables}

Les données sensibles (clé API Bungie) sont stockées dans des variables d’environnement et ne figurent jamais dans le code source.

Un fichier \texttt{.env} est utilisé en local, tandis que les secrets sont configurés dans GitHub Actions pour les déploiements automatisés.

\section{Intégration continue (CI)}

\subsection{Objectifs de la CI}

L’intégration continue vise à :
\begin{itemize}
    \item détecter rapidement les erreurs,
    \item garantir la qualité du code,
    \item empêcher l’intégration de code non fonctionnel.
\end{itemize}

\subsection{Pipeline GitHub Actions}

\begin{lstlisting}[language=yaml]
name: CI Destiny Companion

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  ci:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Installation Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Installation des dépendances
        run: |
          cd backend
          npm ci

      - name: Lint du code
        run: |
          cd backend
          npm run lint

      - name: Tests unitaires
        run: |
          cd backend
          npm test
\end{lstlisting}

\section{Quality Gates}

Le pipeline CI applique les règles suivantes :
\begin{itemize}
    \item les tests doivent réussir,
    \item le linting ne doit produire aucune erreur,
    \item le pipeline est bloqué en cas d’échec.
\end{itemize}

Ces contrôles garantissent une validation continue minimale mais efficace.

\section{Déploiement continu (CD)}

\subsection{Principe de déploiement}

Le déploiement est déclenché uniquement après validation complète de la CI.  
L’image Docker est reconstruite puis redémarrée sur le serveur cible.

Cette approche limite les risques tout en restant simple à maintenir.

\subsection{Commandes de déploiement}

\begin{verbatim}
docker-compose build
docker-compose up -d
\end{verbatim}

\section{Monitoring et logs}

\subsection{Logs applicatifs}

Les logs générés par l’application Node.js sont accessibles via Docker :

\begin{verbatim}
docker logs destiny-backend
\end{verbatim}

Ils permettent de diagnostiquer rapidement les erreurs applicatives.

\subsection{Surveillance basique}

Les éléments surveillés sont :
\begin{itemize}
    \item disponibilité de l’API,
    \item erreurs serveur,
    \item temps de réponse.
\end{itemize}

Ces indicateurs sont suffisants pour un projet individuel.

\section{Documentation de déploiement}

\subsection{Prérequis}

\begin{itemize}
    \item Docker installé,
    \item accès à un terminal,
    \item clé API Bungie valide.
\end{itemize}

\subsection{Lancement de l’application}

\begin{verbatim}
docker-compose up -d
\end{verbatim}

\subsection{Arrêt et redémarrage}

\begin{verbatim}
docker-compose down
docker-compose up -d
\end{verbatim}

\section{Conclusion}

Ce chapitre présente une chaîne CI/CD complète et réaliste, adaptée à un projet de niveau Concepteur Développeur d’Applications.

La mise en œuvre de Docker, GitHub Actions et des quality gates démontre une compréhension concrète des enjeux de déploiement, tout en respectant les contraintes d’un projet individuel.
